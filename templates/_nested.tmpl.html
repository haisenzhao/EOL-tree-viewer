<!-- 
Maps EOL API json hierarchy_entries responses into nested <div>s, each with a 
head and body div. The body div contains the node's children, if any. 

Note: Layout helper script assumes jQuery 
-->

<script id="root" type="x-jquery-tmpl">
	<div class='node selectable root' id='${$item.getID()}'>
		{{tmpl($item.data, $item.helper) '#head-breadcrumb'}}
		{{tmpl($item.data, $item.helper) '#body'}}
	</div>
</script>

<script id="node" type="x-jquery-tmpl">
	{{if $item.displayableNode()}}
		<div class='node selectable' id='${$item.getID()}' data-vole-url='${$item.getURL()}'>
			{{tmpl($item.data, $item.helper) '#head'}}
			{{tmpl($item.data, $item.helper) '#body'}}
		</div>
	{{/if}}
</script>

<script id="head" type="x-jquery-tmpl">
	<div class='head'>
		<span>${$item.getName()}</span>
	</div>
</script>

<script id="body" type="x-jquery-tmpl">
	{{if $item.hasChildren()}}
		<div class='body children to-fetch'></div>
	{{else}}	
		<div class='body leaf'></div>
	{{/if}}
</script>

<script id="head-breadcrumb" type="x-jquery-tmpl">
	<div class='head'>
		<span class='breadcrumbs'>
			<span class='breadcrumb current'>${$item.getName()}</span>

			<span class='breadcrumb ancestors'>
				{{tmpl($item.getAncestors(), $item.helper) '#breadcrumb-ancestor'}}
			</span>
			
		</span>
	</div>
</script>

<script id="breadcrumb-ancestor" type="x-jquery-tmpl">
	${' < '}<a class='breadcrumb ancestor' id='${$item.getID()}' data-vole-url='${$item.getURL()}'>${$item.getName()}</a>
</script>

<script>
	(function () {
		var rootTemplateID = '#root',
			nodeTemplateID = '#node';
		
		function fetchChildren(container, templateHelper, maxDepth) {
			container.find("div.body.children.to-fetch").each(function(){
				var parent = jQuery(this),
					tmplItem = parent.tmplItem(),
					parentDepth = tmplItem.data.voleDepth;

				if (parentDepth < maxDepth && parent.width() > 50 && parent.height() > 50) {
					parent.addClass("async-wait");
					tmplItem.getChildrenAsync().done(function (children) {
						jQuery.each(children, function(index, child) {
							child.voleDepth = parentDepth + 1;
						});
						
						var childNodes = jQuery(nodeTemplateID).tmpl(children, templateHelper);  
						
						parent.empty().append(childNodes);
						
						vole.getLayout().doLayout(container, getNodeOps(), true);
	
						parent.removeClass("to-fetch async-wait");
					});
				} else {
					parent.addClass("leaf");
				}
				
				parent.removeClass("to-fetch");
			});
		}

		function getNodeOps() {
			return jQuery.extend({}, vole.getAreaModel(), view.layoutOps);
		}
		
		var view = {
			name: 'nested',
			show: function (tree, templateHelper, container) {
				tree.voleDepth = 0;
				var view = jQuery(rootTemplateID).tmpl(tree, templateHelper);
				container.empty().append(view);

				vole.getLayout().doLayout(view, getNodeOps(), true);
				//TODO handle leaves either here or in the template
				
				fetchChildren(view, templateHelper, vole.getViewDepth());
			},
			resize: function () {
				var root = jQuery("div.node.root");
				vole.getLayout().doLayout(root, getNodeOps(), true);
				
				//if the root is also a leaf, resize its image
				root.children("div.body").children("img")[0].resizeToFill();
			},
			layoutOps: {
				setBounds: function setBounds(node, bounds) {
					bounds = {
						x:Math.round(bounds.x),
						y:Math.round(bounds.y),
						width:Math.round(bounds.width),
						height:Math.round(bounds.height)
					}
					var borderWidth = 1,
					image = {};
					//TODO check actual border width once at startup
					
					node = jQuery(node);
					node.css({'left':bounds.x, 'top':bounds.y});
					node.height(bounds.height - 2 * borderWidth);
					node.width(bounds.width - 2 * borderWidth);

					//if body contents is an image (i.e. node is displayed as a leaf) resize the image
					image = node.children("div.body").children("img.resizable")[0];
					if (image) {
						image.resizeToFill();
					}
				},
			
				/* takes a DOM div.node and returns its div.node children (not the 
				 * immediate DOM children, which would just be the header and body 
				 * container) 
				 */
				getLayoutChildren: function getLayoutChildren(node) {
					var childContainer = jQuery(node).children("div.body").first();
					return jQuery.makeArray(childContainer.children("div.node"));
				},
			
				/* takes a DOM div.node and returns the bounds of its child container */
				getLayoutBounds: function getLayoutBounds(node) {
					var childContainer = jQuery(node).children("div.body").first();
					return {
						x: 0,
						y: 0,
						width: childContainer.width(),
						height: childContainer.height()
					};
				}
			}
		}

		//TODO add methods to setup and tear down the event handlers
		jQuery("div.node, a.breadcrumb.ancestor").live("click", function(){
			vole.view(jQuery(this).attr("data-vole-url"));
			return false; //only innermost node handles event
		});

		//TODO change this to a plain old function in the closure of setBounds
		HTMLImageElement.prototype.resizeToFill = function resizeToFill() {
			var container = this.parentNode,
				imageAR = this.naturalWidth / this.naturalHeight,
				containerAR = container.clientWidth / container.clientHeight,
				overlapPercent,
				style = this.style;

			if (imageAR >= containerAR) {
				overlapPercent = 50 * (imageAR / containerAR - 1);

				//image aspect ratio is wider than container: fit height and center overlapping width
				style.top = "auto";
				style.height = "100%";
				style.width = "auto";
				style.left = -overlapPercent + "%";
			} else {
				overlapPercent = 50 * (containerAR / imageAR - 1);

				//image aspect ratio is taller than container: fit width and center overlapping height
				style.left ="auto";
				style.width = "100%";
				style.height = "auto";
				style.top = -overlapPercent + "%";
			}
		};
		
		vole.addView(view.name, view);
	})();
</script>